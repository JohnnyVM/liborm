/** \file database_connection_execute.c
 * \brief execute stmt
 * \todo rewrite this file
 * \todo add bind input parameters
 */
#define SQLCA_STORAGE_CLASS extern
#include <sqlca.h>
#include <stdio.h>

#include <assert.h>
#include <stdlib.h>

#define __STDC_WANT_DEC_FP__
#include <float.h>

#include "inner_driver_oracle.h"
#include "connection/connection.h"
#include "driver/oracle/connection_data.h"
#include "oracle_types.h"

/**
 * \brief return number of parameters spected counting : in stmt
 * \todo for input aprameters this function need a c wrapper
 */
struct connection_result
driver_ora_execute_many(struct oracle_connection_data* dbconn, const char* stmt, void* rows) {
	struct connection_result db_stat = {0};

	EXEC SQL BEGIN DECLARE SECTION;
	int i;
	sql_context ctx = dbconn->ctx;
	unsigned char* database = dbconn->dbname;
	unsigned char* input_descriptor = dbconn->input_descriptor;
	unsigned char* output_descriptor = dbconn->output_descriptor;
	int input_count, output_count;
	const char* statement = stmt;
	char name[INDICATOR_NAME_LENGTH];
	int type;
	int length;
	short indicator;
	unsigned char* data;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL CONTEXT USE :ctx;
	EXEC SQL AT :database DECLARE db_execute_stmt STATEMENT;
	EXEC SQL AT :database PREPARE db_execute_stmt FROM :statement;
	if(sqlca.sqlcode) {
		db_stat.state = DATABASE_ERROR;
		return db_stat;
	}

	EXEC SQL AT :database DESCRIBE INPUT db_execute_stmt USING SQL DESCRIPTOR GLOBAL :input_descriptor;
	if(sqlca.sqlcode) {
		db_stat.state = DATABASE_ERROR;
		return db_stat;
	}

	EXEC SQL GET DESCRIPTOR GLOBAL :input_descriptor :input_count = COUNT;
	if(sqlca.sqlcode) {
		db_stat.state = DATABASE_ERROR;
		return db_stat;
	}

	if(rows) { assert(0); }
	/*for(i = 1; rows && i <= (int)rows->_row.length; ++i) {
		EXEC SQL GET DESCRIPTOR GLOBAL :input_descriptor VALUE :i
			:name = NAME;
		// TODO proces paramters, probably the best is move to a function
		// process input parameters or similar
		if(sqlca.sqlcode) {
			db_stat.state = DATABASE_ERROR;
			return db_stat;
		}
	}*/

	EXEC SQL AT :database DESCRIBE OUTPUT db_execute_stmt USING SQL DESCRIPTOR GLOBAL :output_descriptor;
	if(sqlca.sqlcode) {
		db_stat.state = DATABASE_ERROR;
		return db_stat;
	}

	EXEC SQL GET DESCRIPTOR GLOBAL :output_descriptor :output_count = COUNT;
	if(sqlca.sqlcode) {
		db_stat.state = DATABASE_ERROR;
		return db_stat;
	}

	EXEC SQL AT :database EXECUTE db_execute_stmt USING SQL DESCRIPTOR GLOBAL :input_descriptor;
	// the library return "NOT ROW FOUND" for operations that return 0 rows affected
	if(sqlca.sqlcode && sqlca.sqlcode != ORA_NOT_FOUND) {
		db_stat.state = DATABASE_ERROR;
		return db_stat;
	}

	db_stat.changes = sqlca.sqlerrd[2];
	if(output_count) {
		db_stat.state = SQL_ROWS;
	}

	return db_stat;
}

struct connection_result
driver_ora_fields_count(struct oracle_connection_data* dbconn, unsigned* i) {
	struct connection_result state = {0};
	EXEC SQL BEGIN DECLARE SECTION;
	sql_context ctx = dbconn->ctx;
	unsigned char* database = dbconn->dbname;
	unsigned char* output_descriptor = dbconn->output_descriptor;
	int output_count;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL CONTEXT USE :ctx;
	EXEC SQL GET DESCRIPTOR GLOBAL :output_descriptor :output_count = COUNT;
	if(sqlca.sqlcode) {
		state.state = DATABASE_ERROR;
		return state;
	}
	*i = output_count;
	return state;
}

/**
 * Quirks, in the documentation said that
 * CURSOR are declared values at scope file(but in other parts of the documentation are declared as function level)
 * and seem like some gramaticals error too happen, well in general y dont understad why this happen BUT
 * after a few try-error tests... (with threads cursor declared a function level?) this work
 * specify nathing... probably is worth of a further study... becouse sometimes too work in diferent files
 * anyway, open cursor and seem like open/fetch/close work better toghether (sometimes)
 * \param many number of rows required, can be returned less
 * \
 */
struct connection_result
driver_ora_cursor_open(struct oracle_connection_data* dbconn, unsigned nfields) {
	struct connection_result state = {0};
	EXEC SQL BEGIN DECLARE SECTION;
	sql_context ctx = dbconn->ctx;
	unsigned char* database = dbconn->dbname;
	unsigned char* output_descriptor = dbconn->output_descriptor;
	int type;
	int precision;
	int length;
	int scale;
	int i;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL CONTEXT USE :ctx;

	EXEC SQL AT :database DECLARE db_execute_cursor CURSOR FOR db_execute_stmt;

	EXEC SQL AT :database OPEN db_execute_cursor;
	if(sqlca.sqlcode) {
		state.state = DATABASE_ERROR;
		return state;
	}

	for(i = 1; (unsigned)i <= nfields; ++i) {
		EXEC SQL GET DESCRIPTOR GLOBAL :output_descriptor VALUE :i
			:type = TYPE,
			:precision = PRECISION,
			:length = LENGTH,
			:scale = SCALE;
		if(sqlca.sqlcode) {
			driver_ora_cursor_close(dbconn);
			state.state = DATABASE_ERROR;
			return state;
		}
		// the type Number have to be setted forward
		if(type == ORA_NUMBER && scale <= 0 && precision == 0) {
			precision = DEC128_MANT_DIG;
			length = 8; // maximun oracle size
			scale = scale < 0 ? 0 : scale;
		}
		EXEC SQL SET DESCRIPTOR GLOBAL :output_descriptor VALUE :i
			TYPE = :type,
			LENGTH = :length,
			SCALE = :scale,
			PRECISION = :precision;
		if(sqlca.sqlcode) {
			driver_ora_cursor_close(dbconn);
			state.state = DATABASE_ERROR;		
			return state;
		}
	}
	return state;
}

struct connection_result
driver_ora_cursor_close(struct oracle_connection_data* dbconn) {
	struct connection_result state = {0};
	EXEC SQL BEGIN DECLARE SECTION;
	unsigned char* database = dbconn->dbname; // Nasty dragon, not remove
	sql_context ctx = dbconn->ctx;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL CONTEXT USE :ctx;
	EXEC SQL CLOSE db_execute_cursor;

	if(sqlca.sqlcode) {
		state.state = DATABASE_ERROR;
	}
	return state;
}

struct connection_result
driver_ora_get_descriptor_column(struct oracle_connection_data* dbconn, unsigned nfield, struct ora_database_type *result) {
	struct connection_result state = {0};
	EXEC SQL BEGIN DECLARE SECTION;
	sql_context ctx = dbconn->ctx;
	unsigned char* database = dbconn->dbname;
	unsigned char* output_descriptor = dbconn->output_descriptor;
	int type;
	int length;
	char name[INDICATOR_NAME_LENGTH];
	unsigned char* data;
	int octet_length;
	short returned_length;
	short returned_octet_length;
	int precision;
	int scale;
	int nullable;
	short indicator;
	const int pos = nfield;
	int len;
	EXEC SQL END DECLARE SECTION;

	result->indicator = -1;

	EXEC SQL CONTEXT USE :ctx;

	EXEC SQL GET DESCRIPTOR GLOBAL :output_descriptor VALUE :pos
		:type = TYPE,
		:length = LENGTH,
		:octet_length = OCTET_LENGTH,
		:returned_length = RETURNED_LENGTH,
		:returned_octet_length = RETURNED_OCTET_LENGTH,
		:precision = PRECISION,
		:scale = SCALE,
		:nullable = NULLABLE,
		:indicator = INDICATOR,
		:name = NAME;
	if(sqlca.sqlcode) {
		state.state = DATABASE_ERROR;
		return state;
	}
	len = snprintf(NULL, 0, "%s", name);
	if(len < 0 ||len >= (int)sizeof name) {
		assert(!"indicator_name_length too short or nasty error");
		state.state = NO_MEMORY;
		return state;
	}

	if(indicator != -1) { // Not null
		data = malloc((size_t)octet_length);
		if(data == NULL) {
			state.state = NO_MEMORY;
			return state;
		}

		EXEC SQL GET DESCRIPTOR GLOBAL :output_descriptor VALUE :pos
			:data = DATA;
		if(sqlca.sqlcode) {
			free(data);
			state.state = DATABASE_ERROR;
			return state;
		}
	}

	result->type = type;
	result->length = length;
	result->returned_length = returned_length;
	result->octet_length = octet_length;
	result->returned_octet_length = returned_octet_length;
	result->precision = precision;
	result->scale = scale;
	result->nullable = nullable;
	result->indicator = indicator;
	len = snprintf(result->name, INDICATOR_NAME_LENGTH, "%s", name);
	if(len < 0 || len >= (int)INDICATOR_NAME_LENGTH) {
		assert(!"indicator_name_length too short or nasty error");
		free(data);
		state.state = NO_MEMORY;
		return state;
	}
	result->character_set_name = NULL;
	result->data = data;

	state.changes = sqlca.sqlerrd[2];

	return state;
}

struct connection_result
driver_ora_fetch(struct oracle_connection_data* dbconn, unsigned* changes) {
	struct connection_result state = {0};

	EXEC SQL BEGIN DECLARE SECTION;
	sql_context ctx = dbconn->ctx;
	unsigned char* database = dbconn->dbname;
	unsigned char* output_descriptor = dbconn->output_descriptor;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL CONTEXT USE :ctx;

	EXEC SQL AT :database FETCH db_execute_cursor INTO DESCRIPTOR GLOBAL :output_descriptor;

	state.state = SQL_ROWS;
	if(sqlca.sqlcode) {
		state.state = DATABASE_ERROR;
		if(sqlca.sqlcode == ORA_NOT_FOUND) {
			state.state = SQL_DONE;
			return state;
		}
	}

	(*changes) += sqlca.sqlerrd[2];
	return state;
}

char* driver_ora_short_error_message(void) {
	return sqlca.sqlerrm.sqlerrmc;
}