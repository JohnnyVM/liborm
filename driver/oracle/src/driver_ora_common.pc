#define SQLCA_STORAGE_CLASS extern
#include <sqlca.h>
#include <stdio.h>

#include <assert.h>
#include <stdlib.h>

#include "inner_driver_oracle.h"
#include "driver/oracle/connection_data.h"
#include "oracle_types.h"
#include "liborm/connection/types.h"
#include "liborm/connection/state.h"


char* driver_ora_short_error_message(void) {
	return sqlca.sqlerrm.sqlerrmc;
}

conn_state driver_ora_set_descriptor_input(struct oracle_connection_data* dbconn, unsigned nfield, struct ora_database_type *result) {
	EXEC SQL BEGIN DECLARE SECTION;
	sql_context ctx = dbconn->ctx;
	unsigned char* database = dbconn->dbname;
	unsigned char* input_descriptor = dbconn->input_descriptor;
	int type = result->type;
	int length = result->length;
	unsigned char* data = NULL;
	short indicator = result->indicator;
	const int pos = (int)nfield;
	EXEC SQL END DECLARE SECTION;

	if(result->indicator != -1) {
		data = result->data;
	}

	EXEC SQL CONTEXT USE :ctx;
	EXEC SQL SET DESCRIPTOR GLOBAL :input_descriptor VALUE :pos
		TYPE = :type,
		LENGTH = :length,
		INDICATOR = :indicator,
		DATA = :data;
	if(sqlca.sqlcode) {
		return DATABASE_ERROR;
	}

	return SQL_DONE;
}

conn_state driver_ora_get_descriptor_column(struct oracle_connection_data* dbconn, unsigned nfield, struct ora_database_type *result) {
	EXEC SQL BEGIN DECLARE SECTION;
	sql_context ctx = dbconn->ctx;
	unsigned char* database = dbconn->dbname;
	unsigned char* output_descriptor = dbconn->output_descriptor;
	int type;
	int length;
	char name[INDICATOR_NAME_LENGTH];
	unsigned char* data = result->data;
	int octet_length;
	short returned_length;
	short returned_octet_length;
	int precision;
	int scale;
	int nullable;
	short indicator;
	const int pos = (int)nfield;
	int len;
	EXEC SQL END DECLARE SECTION;

	result->indicator = -1;

	EXEC SQL CONTEXT USE :ctx;
	EXEC SQL GET DESCRIPTOR GLOBAL :output_descriptor VALUE :pos
		:type = TYPE,
		:length = LENGTH,
		:octet_length = OCTET_LENGTH,
		:returned_length = RETURNED_LENGTH,
		:returned_octet_length = RETURNED_OCTET_LENGTH,
		:precision = PRECISION,
		:scale = SCALE,
		:nullable = NULLABLE,
		:indicator = INDICATOR,
		:name = NAME;
	if(sqlca.sqlcode) {
		return DATABASE_ERROR;
	}
	len = snprintf(NULL, 0, "%s", name);
	if(len < 0 ||len >= (int)sizeof name) {
		assert(!"indicator_name_length too short or nasty error");
		return NO_MEMORY;
	}

	if(indicator != -1) { // Not null
		data = malloc((size_t)octet_length);
		if(data == NULL) {
			return NO_MEMORY;
		}

		EXEC SQL GET DESCRIPTOR GLOBAL :output_descriptor VALUE :pos
			:data = DATA;
		if(sqlca.sqlcode) {
			free(data);
			return DATABASE_ERROR;
		}
	}

	result->type = type;
	result->length = length;
	result->returned_length = returned_length;
	result->octet_length = octet_length;
	result->returned_octet_length = returned_octet_length;
	result->precision = precision;
	result->scale = scale;
	result->nullable = nullable;
	result->indicator = indicator;
	len = snprintf(result->name, INDICATOR_NAME_LENGTH, "%s", name);
	if(len < 0 || len >= (int)INDICATOR_NAME_LENGTH) {
		assert(!"indicator_name_length too short or nasty error");
		free(data);
		return NO_MEMORY;
	}
	result->character_set_name = NULL;
	result->data = data;

	return SQL_DONE;
}

/* return the number of expected output parameters*/
conn_state driver_ora_fields_out_count(struct oracle_connection_data* dbconn, unsigned* i) {
	struct connection_result state = {0};
	EXEC SQL BEGIN DECLARE SECTION;
	sql_context ctx = dbconn->ctx;
	unsigned char* database = dbconn->dbname;
	unsigned char* output_descriptor = dbconn->output_descriptor;
	int output_count;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL CONTEXT USE :ctx;
	EXEC SQL GET DESCRIPTOR GLOBAL :output_descriptor :output_count = COUNT;
	if(sqlca.sqlcode) {
		return DATABASE_ERROR;
	}
	assert(output_count >= 0);
	*i = (unsigned)output_count;
	return SQL_DONE;
}

/* return the number of expected input parameters*/
conn_state driver_ora_fields_in_count(struct oracle_connection_data* dbconn, unsigned* i) {
	struct connection_result state = {0};
	EXEC SQL BEGIN DECLARE SECTION;
	sql_context ctx = dbconn->ctx;
	unsigned char* database = dbconn->dbname;
	unsigned char* input_descriptor = dbconn->input_descriptor;
	int input_count;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL CONTEXT USE :ctx;
	EXEC SQL GET DESCRIPTOR GLOBAL :input_descriptor :input_count = COUNT;
	if(sqlca.sqlcode) {
		return DATABASE_ERROR;
	}
	assert(input_count >= 0);
	*i = (unsigned)input_count;
	return SQL_DONE;
}