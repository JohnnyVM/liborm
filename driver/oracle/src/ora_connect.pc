#include <stdlib.h>
#include <stdio.h>

#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern
#include <sqlca.h>
#include <sqlcpr.h>

#include "inner_driver_oracle.h"
#include "connection/connection.h"
#include "driver/oracle/connection_data.h"

/**
 * \brief enable thread
 *
 * Normally should be considered a memory leak but is a expected and defined behaviour https://docs.oracle.com/cd/A58617_01/server.804/a58233/adv.htm#421518
 * at least for old version, i didnt found new information about that
 * for now we will ignore that but have to be treated carefully and memory usage reviewed
 * Preliminary test show taht the leak only appear with CPOOL=YES and oposite that documentation claim in the test seem like a lost
 * in the performace (10%~20% loss of performance) more tests needed
 * 
 * \warning this set a global variable that cant be free or accessed in any normal way (memory leak) but is small
 * \return struct connection_result 
 */
 struct connection_result
driver_ora_enable_threads(void) {
	struct connection_result state = {0};
	EXEC SQL ENABLE THREADS;
	if(sqlca.sqlcode) {
		assert(!"Enable threads error");
		state.state = DATABASE_ERROR;
		return state;
	}
	return state;
};

struct connection_result
driver_ora_connect(struct oracle_connection_data* dbconn) {
	struct connection_result state = {0};

	EXEC SQL BEGIN DECLARE SECTION;
	sql_context ctx = dbconn->ctx;
	char* user = dbconn->user;
	unsigned char* database = dbconn->dbname;
	unsigned char* connect_string = dbconn->connect_string;
	char* password = dbconn->password;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL CONTEXT ALLOCATE :ctx;
	if(sqlca.sqlcode) {
		assert(!"Error at close connection");
		state.state = DATABASE_ERROR;
		dbconn->ctx = NULL;
		return state;
	}
	dbconn->ctx = ctx;
	EXEC SQL CONTEXT USE :ctx;

	state = allocate_descriptor_global(dbconn, dbconn->input_descriptor);
	if(state.state) {
		assert(!"Error at close connection");
		return state;
	}

	state = allocate_descriptor_global(dbconn, dbconn->output_descriptor);
	if(state.state) {
		assert(!"Error at close connection");
		return state;
	}

	EXEC SQL CONNECT :user IDENTIFIED BY :password AT :database USING :connect_string;
	if(sqlca.sqlcode) {
		assert(!"Error at close connection");
		state.state = DATABASE_ERROR;
		EXEC SQL CONTEXT FREE :ctx;
		dbconn->ctx = NULL;
		return state;
	}

	return state;
}

