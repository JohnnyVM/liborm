#include <stdlib.h>
#include <stdio.h>

#define SQLCA_STORAGE_CLASS extern
#define ORACA_STORAGE_CLASS extern
#include <sqlca.h>
#include <sqlcpr.h>

#include "inner_driver_oracle.h"
#include "driver/oracle/connection_data.h"
#include "liborm/connection/types.h"
#include "liborm/connection/state.h"

/**
 * \brief enable thread
 * 
 * \warning this set a global variable that cant be free or accessed in any normal way (memory leak) but is small
 * \return struct connection_result 
 */
conn_state driver_ora_enable_threads(void) {
	EXEC SQL ENABLE THREADS;
	if(sqlca.sqlcode) {
		assert(!"Enable threads error");
		return DATABASE_ERROR;
	}
	return SQL_DONE;
};

conn_state driver_ora_connect(struct oracle_connection_data* dbconn) {

	EXEC SQL BEGIN DECLARE SECTION;
	sql_context ctx = dbconn->ctx;
	char* user = dbconn->user;
	unsigned char* database = dbconn->dbname;
	unsigned char* connect_string = dbconn->connect_string;
	char* password = dbconn->password;
	EXEC SQL END DECLARE SECTION;

	EXEC SQL CONTEXT ALLOCATE :ctx;
	if(sqlca.sqlcode) {
		assert(!"Error at connection");
		dbconn->ctx = NULL;
		return DATABASE_ERROR;
	}
	dbconn->ctx = ctx;
	EXEC SQL CONTEXT USE :ctx;

	conn_state state = allocate_descriptor_global(dbconn, dbconn->input_descriptor);
	if(state) {
		assert(!"Error at connection");
		return DATABASE_ERROR;
	}

	state = allocate_descriptor_global(dbconn, dbconn->output_descriptor);
	if(state) {
		assert(!"Error at connection");
		return DATABASE_ERROR;
	}

	EXEC SQL CONNECT :user IDENTIFIED BY :password AT :database USING :connect_string;
	if(sqlca.sqlcode) {
		assert(!"Error at connection");
		EXEC SQL CONTEXT FREE :ctx;
		dbconn->ctx = NULL;
		return DATABASE_ERROR;
	}

	return SQL_DONE;
}

